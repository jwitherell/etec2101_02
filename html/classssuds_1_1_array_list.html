<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SSUDS (SSU Data Structures): ssuds::ArrayList&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SSUDS (SSU Data Structures)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ssuds</b></li><li class="navelem"><a class="el" href="classssuds_1_1_array_list.html">ArrayList</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classssuds_1_1_array_list-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ssuds::ArrayList&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> is an array-based data structure.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array__list_8h_source.html">array_list.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The job of <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> is to traverse the data in an <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a>. <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> wouldn't necessarily <em>need</em> an iterator since the internal array supports random access, but this is a chance to get used to the iterator pattern, which is much more useful for the user in other classes. We might eventually use inheritance to derive this class from some common iterator class.  <a href="classssuds_1_1_array_list_1_1_array_list_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8f2e0b06a3bf7bdc5fbe20c95cec1c6b" id="r_a8f2e0b06a3bf7bdc5fbe20c95cec1c6b"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f2e0b06a3bf7bdc5fbe20c95cec1c6b">operator[]</a> (int index) const</td></tr>
<tr class="memdesc:a8f2e0b06a3bf7bdc5fbe20c95cec1c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the data item at the given index. This method (unlike at) does NOT do bounds-checking (and so is very slightly faster)  <br /></td></tr>
<tr class="separator:a8f2e0b06a3bf7bdc5fbe20c95cec1c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6334ec5abee5dbc48aafcdf46a390670" id="r_a6334ec5abee5dbc48aafcdf46a390670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6334ec5abee5dbc48aafcdf46a390670">operator=</a> (const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a6334ec5abee5dbc48aafcdf46a390670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the creation of a deep copy when the user assigns an existing <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> to another. This method also handles the case where the user self-copies (a = a).  <br /></td></tr>
<tr class="separator:a6334ec5abee5dbc48aafcdf46a390670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17073605b1b8e31ca126e61db633c57d" id="r_a17073605b1b8e31ca126e61db633c57d"><td class="memItemLeft" align="right" valign="top"><a id="a17073605b1b8e31ca126e61db633c57d" name="a17073605b1b8e31ca126e61db633c57d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayList</b> ()</td></tr>
<tr class="memdesc:a17073605b1b8e31ca126e61db633c57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Default constructor. <br /></td></tr>
<tr class="separator:a17073605b1b8e31ca126e61db633c57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8c635fece5189238f20e4df1e9e899" id="r_acc8c635fece5189238f20e4df1e9e899"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc8c635fece5189238f20e4df1e9e899">ArrayList</a> (const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a> &amp;other)</td></tr>
<tr class="memdesc:acc8c635fece5189238f20e4df1e9e899"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy-constructor. Used in these two cases <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> me(other_array_list); <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> me = other_array_list; Note: this does NOT use the =operator ... me = other_array_list; This WOULD use the =operator.  <br /></td></tr>
<tr class="separator:acc8c635fece5189238f20e4df1e9e899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad351338073d3009c376cc41ebd1a3fa1" id="r_ad351338073d3009c376cc41ebd1a3fa1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad351338073d3009c376cc41ebd1a3fa1">ArrayList</a> (<a class="el" href="classssuds_1_1_array_list.html">ArrayList</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ad351338073d3009c376cc41ebd1a3fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move-constructor. This makes a shallow copy of other. A better way to explain might be to say that this constructor "steals" the data from the other array. The compiler calls this method when <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> other is about to go away, and it is being assigned to us. Making a full copy would be much more expensive than this.  <br /></td></tr>
<tr class="separator:ad351338073d3009c376cc41ebd1a3fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2054692182bb324c826024ccc10a63b7" id="r_a2054692182bb324c826024ccc10a63b7"><td class="memItemLeft" align="right" valign="top"><a id="a2054692182bb324c826024ccc10a63b7" name="a2054692182bb324c826024ccc10a63b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayList</b> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:a2054692182bb324c826024ccc10a63b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer-list constructor. <br /></td></tr>
<tr class="separator:a2054692182bb324c826024ccc10a63b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334e1f8861f34a0da7230aeec7571e3c" id="r_a334e1f8861f34a0da7230aeec7571e3c"><td class="memItemLeft" align="right" valign="top"><a id="a334e1f8861f34a0da7230aeec7571e3c" name="a334e1f8861f34a0da7230aeec7571e3c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~ArrayList</b> ()</td></tr>
<tr class="memdesc:a334e1f8861f34a0da7230aeec7571e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a334e1f8861f34a0da7230aeec7571e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7c9bd58748ea361ca69b45c1c66681" id="r_a3a7c9bd58748ea361ca69b45c1c66681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a7c9bd58748ea361ca69b45c1c66681">append</a> (const T &amp;val)</td></tr>
<tr class="memdesc:a3a7c9bd58748ea361ca69b45c1c66681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at the end of the array.  <br /></td></tr>
<tr class="separator:a3a7c9bd58748ea361ca69b45c1c66681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b660cd011f7d236e41e8602412072a" id="r_a78b660cd011f7d236e41e8602412072a"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78b660cd011f7d236e41e8602412072a">at</a> (const unsigned int index) const</td></tr>
<tr class="memdesc:a78b660cd011f7d236e41e8602412072a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the item at the given index. Since it is a reference, this type of operation is allowed: my_float_array.at(5) = 17.3f; my_int_array.at(3)++; This method will raise a std::out_of_range exception if an invalid index is given.  <br /></td></tr>
<tr class="separator:a78b660cd011f7d236e41e8602412072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b21ab65dae2e027da6d40e1214ebb6c" id="r_a1b21ab65dae2e027da6d40e1214ebb6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b21ab65dae2e027da6d40e1214ebb6c">begin</a> () const</td></tr>
<tr class="memdesc:a1b21ab65dae2e027da6d40e1214ebb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an forward <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> "pointing" at the first element (if it exists). If the <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> is empty, this iterator will be equal to end.  <br /></td></tr>
<tr class="separator:a1b21ab65dae2e027da6d40e1214ebb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9f0d67b921ddde2da06bdef3012ca8" id="r_a4e9f0d67b921ddde2da06bdef3012ca8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e9f0d67b921ddde2da06bdef3012ca8">capacity</a> () const</td></tr>
<tr class="memdesc:a4e9f0d67b921ddde2da06bdef3012ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> (this is always greater than or equal to the size)  <br /></td></tr>
<tr class="separator:a4e9f0d67b921ddde2da06bdef3012ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f9aaf226d5c6fde758546102150271" id="r_a29f9aaf226d5c6fde758546102150271"><td class="memItemLeft" align="right" valign="top"><a id="a29f9aaf226d5c6fde758546102150271" name="a29f9aaf226d5c6fde758546102150271"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a29f9aaf226d5c6fde758546102150271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the array back to its original state. <br /></td></tr>
<tr class="separator:a29f9aaf226d5c6fde758546102150271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89f6f81f6ab34575525ed973c81146d" id="r_ae89f6f81f6ab34575525ed973c81146d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae89f6f81f6ab34575525ed973c81146d">end</a> () const</td></tr>
<tr class="memdesc:ae89f6f81f6ab34575525ed973c81146d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name can be a bit mis-leading, but this iterator does NOT return an iterator referring to the LAST element. Instead, it returns a special value that indicates this is an invalid iterator (or we're done forward-traversing)  <br /></td></tr>
<tr class="separator:ae89f6f81f6ab34575525ed973c81146d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82856a033e2fd787203e1980c912b894" id="r_a82856a033e2fd787203e1980c912b894"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82856a033e2fd787203e1980c912b894">find</a> (const T &amp;val, const unsigned int start_index=0) const</td></tr>
<tr class="memdesc:a82856a033e2fd787203e1980c912b894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index of the first occurrence of the given value.  <br /></td></tr>
<tr class="separator:a82856a033e2fd787203e1980c912b894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a729905bcedb0b493d51d8ad6af594" id="r_aa6a729905bcedb0b493d51d8ad6af594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6a729905bcedb0b493d51d8ad6af594">find</a> (const T &amp;val, const <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> &amp;start) const</td></tr>
<tr class="memdesc:aa6a729905bcedb0b493d51d8ad6af594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the find method above, but using iterators (closer to std::vector)  <br /></td></tr>
<tr class="separator:aa6a729905bcedb0b493d51d8ad6af594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd03aedf6acb7f37086d83a4b5ed9dd2" id="r_abd03aedf6acb7f37086d83a4b5ed9dd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd03aedf6acb7f37086d83a4b5ed9dd2">insert</a> (const T &amp;val, unsigned int index)</td></tr>
<tr class="memdesc:abd03aedf6acb7f37086d83a4b5ed9dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new data item at a given index.  <br /></td></tr>
<tr class="separator:abd03aedf6acb7f37086d83a4b5ed9dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb940eeacbdef50b05dac3f2e681ab8" id="r_a8fb940eeacbdef50b05dac3f2e681ab8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fb940eeacbdef50b05dac3f2e681ab8">output</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a8fb940eeacbdef50b05dac3f2e681ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This basically does the same thing as the &lt;&lt; operator (the syntax is a bit different). I chose to keep it to preserve backwards compatiability with &lt;Lab3 code.  <br /></td></tr>
<tr class="separator:a8fb940eeacbdef50b05dac3f2e681ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff369eaa7e49b33bcfa80aa88906fcd" id="r_a3ff369eaa7e49b33bcfa80aa88906fcd"><td class="memItemLeft" align="right" valign="top"><a id="a3ff369eaa7e49b33bcfa80aa88906fcd" name="a3ff369eaa7e49b33bcfa80aa88906fcd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prepend</b> (const T &amp;val)</td></tr>
<tr class="separator:a3ff369eaa7e49b33bcfa80aa88906fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcec39c654ee0a0d25d033809b1af44" id="r_abfcec39c654ee0a0d25d033809b1af44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfcec39c654ee0a0d25d033809b1af44">rbegin</a> () const</td></tr>
<tr class="memdesc:abfcec39c654ee0a0d25d033809b1af44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a backwards <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> "pointing" at the last element (if it exists). If the <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> is empty, this iterator will be equal to rend.  <br /></td></tr>
<tr class="separator:abfcec39c654ee0a0d25d033809b1af44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4c6c8324263cb02cad484f59bf0039" id="r_a8d4c6c8324263cb02cad484f59bf0039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d4c6c8324263cb02cad484f59bf0039">rend</a> () const</td></tr>
<tr class="memdesc:a8d4c6c8324263cb02cad484f59bf0039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a special value indicating we're done iterating backwards or that this iterator is invalid.  <br /></td></tr>
<tr class="separator:a8d4c6c8324263cb02cad484f59bf0039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8ccd2d3ede88c6041032f2acb7bc17" id="r_afb8ccd2d3ede88c6041032f2acb7bc17"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb8ccd2d3ede88c6041032f2acb7bc17">remove</a> (unsigned int index, bool resize_if_necessary=true)</td></tr>
<tr class="memdesc:afb8ccd2d3ede88c6041032f2acb7bc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a data item at the given index.  <br /></td></tr>
<tr class="separator:afb8ccd2d3ede88c6041032f2acb7bc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aaf7be94a8d5c7c7a54cc9a4ee58763" id="r_a4aaf7be94a8d5c7c7a54cc9a4ee58763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4aaf7be94a8d5c7c7a54cc9a4ee58763">remove</a> (const <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> &amp;it)</td></tr>
<tr class="memdesc:a4aaf7be94a8d5c7c7a54cc9a4ee58763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the value at the given position.  <br /></td></tr>
<tr class="separator:a4aaf7be94a8d5c7c7a54cc9a4ee58763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e4c18bb5fbcacabf07fb7cad038f9b" id="r_a47e4c18bb5fbcacabf07fb7cad038f9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47e4c18bb5fbcacabf07fb7cad038f9b">remove_all</a> (const T val, bool resize_if_necessary=true)</td></tr>
<tr class="memdesc:a47e4c18bb5fbcacabf07fb7cad038f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all occurrences of a given value. Uses find and remove internally to do the removal.  <br /></td></tr>
<tr class="separator:a47e4c18bb5fbcacabf07fb7cad038f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891330426da480ed1bbbfb29fb018b3a" id="r_a891330426da480ed1bbbfb29fb018b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a891330426da480ed1bbbfb29fb018b3a">reserve</a> (unsigned int desired_capacity)</td></tr>
<tr class="memdesc:a891330426da480ed1bbbfb29fb018b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures the internal array has at least this capacity. This is useful if the user knows how many items they will add and don't want to take the performance penalty of the grow operation happening in-between. If the capacity is already higher or equal to the given value, there will be no effect.  <br /></td></tr>
<tr class="separator:a891330426da480ed1bbbfb29fb018b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcd61184deb92c36610e47b91a7b6d5" id="r_adbcd61184deb92c36610e47b91a7b6d5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbcd61184deb92c36610e47b91a7b6d5">size</a> () const</td></tr>
<tr class="memdesc:adbcd61184deb92c36610e47b91a7b6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the internal array (i.e.) how many things are being stored in the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a>.  <br /></td></tr>
<tr class="separator:adbcd61184deb92c36610e47b91a7b6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a07a02cc34fc7c9162e64e3c7a7d1a963" id="r_a07a02cc34fc7c9162e64e3c7a7d1a963"><td class="memItemLeft" align="right" valign="top"><a id="a07a02cc34fc7c9162e64e3c7a7d1a963" name="a07a02cc34fc7c9162e64e3c7a7d1a963"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>grow</b> ()</td></tr>
<tr class="memdesc:a07a02cc34fc7c9162e64e3c7a7d1a963"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal method to resize the array if we are currently at capacity (if we are not, nothing is done) <br /></td></tr>
<tr class="separator:a07a02cc34fc7c9162e64e3c7a7d1a963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18613568842335b1d115958d2f34bab" id="r_ae18613568842335b1d115958d2f34bab"><td class="memItemLeft" align="right" valign="top"><a id="ae18613568842335b1d115958d2f34bab" name="ae18613568842335b1d115958d2f34bab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shrink</b> ()</td></tr>
<tr class="memdesc:ae18613568842335b1d115958d2f34bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal method to see if the array can be shrunk (capacity reduced by half, down to msMinCapacity) <br /></td></tr>
<tr class="separator:ae18613568842335b1d115958d2f34bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac4487ae34800f88539054c3721568c10" id="r_ac4487ae34800f88539054c3721568c10"><td class="memItemLeft" align="right" valign="top"><a id="ac4487ae34800f88539054c3721568c10" name="ac4487ae34800f88539054c3721568c10"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>mCapacity</b></td></tr>
<tr class="memdesc:ac4487ae34800f88539054c3721568c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current number of "slots" AVAILABLE in mData (i.e. the array size) <br /></td></tr>
<tr class="separator:ac4487ae34800f88539054c3721568c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f68ee08bdbaa2f26d017816e4e46e42" id="r_a8f68ee08bdbaa2f26d017816e4e46e42"><td class="memItemLeft" align="right" valign="top"><a id="a8f68ee08bdbaa2f26d017816e4e46e42" name="a8f68ee08bdbaa2f26d017816e4e46e42"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>mSize</b></td></tr>
<tr class="memdesc:a8f68ee08bdbaa2f26d017816e4e46e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many slots are we USING? This will always be less than or equal to mCapacity. <br /></td></tr>
<tr class="separator:a8f68ee08bdbaa2f26d017816e4e46e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43c344eccee75213eb02e96ea3e300e" id="r_ae43c344eccee75213eb02e96ea3e300e"><td class="memItemLeft" align="right" valign="top"><a id="ae43c344eccee75213eb02e96ea3e300e" name="ae43c344eccee75213eb02e96ea3e300e"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><b>mData</b></td></tr>
<tr class="separator:ae43c344eccee75213eb02e96ea3e300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a5b588e6e70c9a9b5cacbc7ce5b971490" id="r_a5b588e6e70c9a9b5cacbc7ce5b971490"><td class="memItemLeft" align="right" valign="top"><a id="a5b588e6e70c9a9b5cacbc7ce5b971490" name="a5b588e6e70c9a9b5cacbc7ce5b971490"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>msMinCapacity</b> = 5</td></tr>
<tr class="memdesc:a5b588e6e70c9a9b5cacbc7ce5b971490"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default (and minimum) capacity of an <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a>. <br /></td></tr>
<tr class="separator:a5b588e6e70c9a9b5cacbc7ce5b971490"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9bb180c1f0d6bbe33037e1a8b0d6f5e4" id="r_a9bb180c1f0d6bbe33037e1a8b0d6f5e4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bb180c1f0d6bbe33037e1a8b0d6f5e4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a> &amp;alist)</td></tr>
<tr class="memdesc:a9bb180c1f0d6bbe33037e1a8b0d6f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the stream operator for ArrayLists.  <br /></td></tr>
<tr class="separator:a9bb180c1f0d6bbe33037e1a8b0d6f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class ssuds::ArrayList&lt; T &gt;</div><p>An <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> is an array-based data structure. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acc8c635fece5189238f20e4df1e9e899" name="acc8c635fece5189238f20e4df1e9e899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8c635fece5189238f20e4df1e9e899">&#9670;&#160;</a></span>ArrayList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::ArrayList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy-constructor. Used in these two cases <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> me(other_array_list); <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> me = other_array_list; Note: this does NOT use the =operator ... me = other_array_list; This WOULD use the =operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad351338073d3009c376cc41ebd1a3fa1" name="ad351338073d3009c376cc41ebd1a3fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad351338073d3009c376cc41ebd1a3fa1">&#9670;&#160;</a></span>ArrayList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::ArrayList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The move-constructor. This makes a shallow copy of other. A better way to explain might be to say that this constructor "steals" the data from the other array. The compiler calls this method when <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> other is about to go away, and it is being assigned to us. Making a full copy would be much more expensive than this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3a7c9bd58748ea361ca69b45c1c66681" name="a3a7c9bd58748ea361ca69b45c1c66681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7c9bd58748ea361ca69b45c1c66681">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element at the end of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the new value to add</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78b660cd011f7d236e41e8602412072a" name="a78b660cd011f7d236e41e8602412072a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b660cd011f7d236e41e8602412072a">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the item at the given index. Since it is a reference, this type of operation is allowed: my_float_array.at(5) = 17.3f; my_int_array.at(3)++; This method will raise a std::out_of_range exception if an invalid index is given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1b21ab65dae2e027da6d40e1214ebb6c" name="a1b21ab65dae2e027da6d40e1214ebb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b21ab65dae2e027da6d40e1214ebb6c">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an forward <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> "pointing" at the first element (if it exists). If the <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> is empty, this iterator will be equal to end. </p>
<dl class="section return"><dt>Returns</dt><dd>A forward iterator referring to the first value value</dd></dl>

</div>
</div>
<a id="a4e9f0d67b921ddde2da06bdef3012ca8" name="a4e9f0d67b921ddde2da06bdef3012ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9f0d67b921ddde2da06bdef3012ca8">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current capacity of the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> (this is always greater than or equal to the size) </p>
<dl class="section return"><dt>Returns</dt><dd>the capacity of the internal array in the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a></dd></dl>

</div>
</div>
<a id="ae89f6f81f6ab34575525ed973c81146d" name="ae89f6f81f6ab34575525ed973c81146d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89f6f81f6ab34575525ed973c81146d">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name can be a bit mis-leading, but this iterator does NOT return an iterator referring to the LAST element. Instead, it returns a special value that indicates this is an invalid iterator (or we're done forward-traversing) </p>
<dl class="section return"><dt>Returns</dt><dd>An "end" type iterator value</dd></dl>

</div>
</div>
<a id="aa6a729905bcedb0b493d51d8ad6af594" name="aa6a729905bcedb0b493d51d8ad6af594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a729905bcedb0b493d51d8ad6af594">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like the find method above, but using iterators (closer to std::vector) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to search for</td></tr>
    <tr><td class="paramname">start</td><td>Either begin, rbegin, or some other iterator to initialize the search</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>And end iterator or rend/end iterator value if not found</dd></dl>

</div>
</div>
<a id="a82856a033e2fd787203e1980c912b894" name="a82856a033e2fd787203e1980c912b894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82856a033e2fd787203e1980c912b894">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index of the first occurrence of the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to search for</td></tr>
    <tr><td class="paramname">start_index</td><td>the index to start searching at</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="abd03aedf6acb7f37086d83a4b5ed9dd2" name="abd03aedf6acb7f37086d83a4b5ed9dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd03aedf6acb7f37086d83a4b5ed9dd2">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new data item at a given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the new value to insert</td></tr>
    <tr><td class="paramname">index</td><td>the index at which to insert (must be &gt;= 0 and &lt;= size) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6334ec5abee5dbc48aafcdf46a390670" name="a6334ec5abee5dbc48aafcdf46a390670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6334ec5abee5dbc48aafcdf46a390670">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp; <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows the creation of a deep copy when the user assigns an existing <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> to another. This method also handles the case where the user self-copies (a = a). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a> we are assigning to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a></dd></dl>

</div>
</div>
<a id="a8f2e0b06a3bf7bdc5fbe20c95cec1c6b" name="a8f2e0b06a3bf7bdc5fbe20c95cec1c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2e0b06a3bf7bdc5fbe20c95cec1c6b">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the data item at the given index. This method (unlike at) does NOT do bounds-checking (and so is very slightly faster) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the thing to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the value at the given index</dd></dl>

</div>
</div>
<a id="a8fb940eeacbdef50b05dac3f2e681ab8" name="a8fb940eeacbdef50b05dac3f2e681ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb940eeacbdef50b05dac3f2e681ab8">&#9670;&#160;</a></span>output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::output </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This basically does the same thing as the &lt;&lt; operator (the syntax is a bit different). I chose to keep it to preserve backwards compatiability with &lt;Lab3 code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream (cout, fp, stringstring, etc.) to write to</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfcec39c654ee0a0d25d033809b1af44" name="abfcec39c654ee0a0d25d033809b1af44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcec39c654ee0a0d25d033809b1af44">&#9670;&#160;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a backwards <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> "pointing" at the last element (if it exists). If the <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html" title="The job of ArrayListIterator is to traverse the data in an ArrayList. ArrayList wouldn&#39;t necessarily ...">ArrayListIterator</a> is empty, this iterator will be equal to rend. </p>
<dl class="section return"><dt>Returns</dt><dd>A backwards iterator referring to the last valid value</dd></dl>

</div>
</div>
<a id="a4aaf7be94a8d5c7c7a54cc9a4ee58763" name="a4aaf7be94a8d5c7c7a54cc9a4ee58763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aaf7be94a8d5c7c7a54cc9a4ee58763">&#9670;&#160;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the value at the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A valid iterator referring to the value that the user wants to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator now referring to the value <em>after</em> the value removed (or end/rend if there's nothing after)</dd></dl>

</div>
</div>
<a id="afb8ccd2d3ede88c6041032f2acb7bc17" name="afb8ccd2d3ede88c6041032f2acb7bc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8ccd2d3ede88c6041032f2acb7bc17">&#9670;&#160;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>resize_if_necessary</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a data item at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the thing to remove (will return a std::out_of_bounds exception if invalid (&lt;0 or &gt;= size)</td></tr>
    <tr><td class="paramname">resize_if_necessary</td><td>if true, the array will be resized if it is now below half capacity</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the data item that was just removed</dd></dl>

</div>
</div>
<a id="a47e4c18bb5fbcacabf07fb7cad038f9b" name="a47e4c18bb5fbcacabf07fb7cad038f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e4c18bb5fbcacabf07fb7cad038f9b">&#9670;&#160;</a></span>remove_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::remove_all </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>resize_if_necessary</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all occurrences of a given value. Uses find and remove internally to do the removal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to remove</td></tr>
    <tr><td class="paramname">resize_if_necessary</td><td>if true, the array will be resized if it is now below half capacity</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of occurrences of that data item that were removed</dd></dl>

</div>
</div>
<a id="a8d4c6c8324263cb02cad484f59bf0039" name="a8d4c6c8324263cb02cad484f59bf0039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4c6c8324263cb02cad484f59bf0039">&#9670;&#160;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_array_list_1_1_array_list_iterator.html">ArrayListIterator</a> <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a special value indicating we're done iterating backwards or that this iterator is invalid. </p>
<dl class="section return"><dt>Returns</dt><dd>A special end value for backwards iteration</dd></dl>

</div>
</div>
<a id="a891330426da480ed1bbbfb29fb018b3a" name="a891330426da480ed1bbbfb29fb018b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891330426da480ed1bbbfb29fb018b3a">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>desired_capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures the internal array has at least this capacity. This is useful if the user knows how many items they will add and don't want to take the performance penalty of the grow operation happening in-between. If the capacity is already higher or equal to the given value, there will be no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desired_capacity</td><td>The capacity will be set to at least this value</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbcd61184deb92c36610e47b91a7b6d5" name="adbcd61184deb92c36610e47b91a7b6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcd61184deb92c36610e47b91a7b6d5">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classssuds_1_1_array_list.html">ssuds::ArrayList</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the internal array (i.e.) how many things are being stored in the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a></dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a9bb180c1f0d6bbe33037e1a8b0d6f5e4" name="a9bb180c1f0d6bbe33037e1a8b0d6f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb180c1f0d6bbe33037e1a8b0d6f5e4">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classssuds_1_1_array_list.html">ArrayList</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>alist</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the stream operator for ArrayLists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>an ostream object (ofstream, stringstream, cout, etc.) </td></tr>
    <tr><td class="paramname">alist</td><td>the <a class="el" href="classssuds_1_1_array_list.html" title="An ArrayList is an array-based data structure.">ArrayList</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (possibly modified) os that was given to us</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ssuds/<a class="el" href="array__list_8h_source.html">array_list.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.1
</small></address>
</div><!-- doc-content -->
</body>
</html>
